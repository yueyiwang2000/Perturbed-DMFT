# def precalcP_innerloop(qx, qind_list, kxind, kyind, kzind, knum, n, G_k, Gkq):
#     P_partial = np.zeros((n, len(qind_list), len(qind_list), len(qind_list)), dtype=complex)
    
#     for qy in qind_list:
#         for qz in qind_list:
#             G_kq = Gkq[:, foldback(kxind + qx, knum), foldback(kyind + qy, knum), foldback(kzind + qz, knum)]
#             for Omind in range(n):
#                 P_partial[Omind, qx, qy, qz] = np.sum(G_k * G_kq[Omind:Omind + n])
    
#     return P_partial


# def precalcP(beta, knum, Gk, Gkq, a=1):
#     n = int(np.shape(Gk)[0] / 2)
#     kind_list = np.arange(knum)
#     if knum % 2 != 0:
#         print('knum should be an even number!')
#         return 0
#     halfknum = int(knum / 2)
#     qind_list = np.arange(halfknum)
#     P = np.zeros((n, halfknum, halfknum, halfknum), dtype=complex)
#     fermion_Omega_ind = np.arange(n)
#     kxind, kyind, kzind = np.meshgrid(kind_list, kind_list, kind_list, indexing='ij')
#     G_k = Gk[:n]

#     results = Parallel(n_jobs=-1)(delayed(precalcP_innerloop)(qx, qind_list, kxind, kyind, kzind, knum, n, G_k, Gkq) for qx in qind_list)


#     for qx, P_partial in enumerate(results):
#         P[:, qx, :, :] = P_partial[:, qx, :, :]

#     return P / beta * (2 * np.pi / a / knum) ** 3

# def precalcP(beta,knum,Gk,Gkq,a=1):
#     n=int(np.shape(Gk)[0]/2)
#     kind_list=np.arange(knum)
#     if knum%2!=0:
#         print('knum should be a even number!')
#         return 0
#     halfknum=int(knum/2)
#     qind_list=np.arange(halfknum)
#     P=np.zeros((n,halfknum,halfknum,halfknum),dtype=complex)
#     fermion_Omega_ind = np.arange(n)
#     kxind, kyind, kzind = np.meshgrid(kind_list, kind_list, kind_list, indexing='ij')
#     G_k=Gk[:n]


#     for qx in qind_list:
#         for qy in qind_list:
#             for qz in qind_list:
#                 G_kq=Gkq[:,foldback(kxind+qx,knum),foldback(kyind+qy,knum),foldback(kzind+qz,knum)]
#                 print(qx,qy,qz)
#                 for Omind in fermion_Omega_ind:
#                     P[Omind,qx,qy,qz]=np.sum(G_k*G_kq[Omind:Omind+n])


#     return P/ beta * (2*np.pi / a / knum) ** 3


# def precalcsig(U,beta,knum,Pk,Gkq,a=1):
    # n=int(np.shape(Pk)[0])
    # qind_list=np.arange(knum)
    # if knum%2!=0:
    #     print('knum should be a even number!')
    #     return 0
    # halfknum=int(knum/2)
    # kind_list=np.arange(halfknum)
    # print(np.concatenate((kind_list[::-1],kind_list)))
    # fulllist_P=np.concatenate((kind_list[::-1],kind_list))
    # fullindx,fullindy,fullindz=np.meshgrid(fulllist_P,fulllist_P,fulllist_P,indexing='ij')
    # fullPk=Pk[:,fullindx,fullindy,fullindz]
    # sig=np.zeros((n,halfknum,halfknum,halfknum),dtype=complex)
    # fermion_Omega_ind = np.arange(n)
    # qxind, qyind, qzind = np.meshgrid(qind_list, qind_list, qind_list, indexing='ij')
    # for kx in kind_list:
    #     for ky in kind_list:
    #         for kz in kind_list:
    #             G_kq=Gkq[:,foldback(qxind+kx,knum),foldback(qyind+ky,knum),foldback(qzind+kz,knum)]
    #             print(kx,ky,kz)
    #             for Omind in fermion_Omega_ind:
    #                 sig[Omind,kx,ky,kz]=np.sum(fullPk*G_kq[Omind:Omind+n])

    # return sig*-1*U*U / beta * (2*np.pi / a / knum) ** 3
