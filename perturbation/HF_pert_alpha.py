import matplotlib.pyplot as plt 
import numpy as np
import os,sys,subprocess,math
import time
sys.path.append('../python_src/')
from mpi4py import MPI
from perturb_lib import *
import perturb_imp as imp
import fft_convolution as fft
import pert_energy_lib as energy
import diagrams
import mpi_module
comm = MPI.COMM_WORLD
rank = comm.Get_rank()
nprocs = comm.Get_size()


'''
This code aims to verify the variational perturbation scheme base on iterative Hartree.
The paper is: arXiv:2210.17423v1
'''
#----------------some functions for test----------
def fermi(eps,beta):
    return 1/(1+np.exp(eps*beta))

def Gtau(U,T,delta,nfreq=500,knum=10):
    beta=1/T
    k1,k2,k3=gen_full_kgrids(knum,1)
    epsk=dispersion(k1,k2,k3)
    om=(2*np.arange(2*nfreq)+1-2*nfreq)*np.pi/beta
    alphak=np.sqrt(delta**2+epsk**2)
    # taulist=np.linspace(0,beta,num=4*nfreq+1)[:4*nfreq]
    taulist=(np.arange(2*nfreq)+1/2)/2/nfreq*beta
    G11_tau=1/2*((1+delta/alphak[None,:,:,:])*(fermi(alphak[None,:,:,:],beta)-1)*np.exp(-alphak[None,:,:,:]*taulist[:,None,None,None])+(1-delta/alphak[None,:,:,:])*(fermi(-alphak[None,:,:,:],beta)-1)*np.exp(alphak[None,:,:,:]*taulist[:,None,None,None]))
    G12_tau=epsk/2/alphak*((fermi(alphak[None,:,:,:],beta)-1)*np.exp(-alphak[None,:,:,:]*taulist[:,None,None,None])-(1-delta/alphak[None,:,:,:])*(fermi(-alphak[None,:,:,:],beta)-1)*np.exp(alphak[None,:,:,:]*taulist[:,None,None,None]))
    return G11_tau,G12_tau

def G12_shift(G12,q,knum,opt):
    """
    opt==1 means shift with sign!
    """
    qx=q[0]
    qy=q[1]
    qz=q[2]
    kind_list = np.arange(knum)
    kxind, kyind, kzind = np.meshgrid(kind_list, kind_list, kind_list, indexing='ij')
    if opt==1:#with factor
        G_12_factor=(-1)**((np.mod(kxind + qx, knum)-(kxind+qx))/knum+(np.mod(kyind + qy, knum)-(kyind+qy))/knum+(np.mod(kzind + qz, knum)-(kzind+qz))/knum)
    else:
        G_12_factor=1.
    G12_kq = G_12_factor*G12[:, np.mod(kxind + qx, knum), np.mod(kyind + qy, knum), np.mod(kzind + qz, knum)]
    return G12_kq

def P11_bf(U,beta,Gtau,qindx,qindy,qindz):
    knum=10
    kind_list = np.arange(knum)
    kxind, kyind, kzind = np.meshgrid(kind_list, kind_list, kind_list, indexing='ij')
    Gshift=Gtau[:, np.mod(kxind + qindx, knum), np.mod(kyind + qindy, knum), np.mod(kzind + qindz, knum)]
    Pq_tau=np.sum(-Gtau[::-1,:,:,:]* Gshift,axis=(1,2,3))/knum**3
    return Pq_tau

def sigma11_bf(U,beta,G11tau,P22tau,kindx,kindy,kindz):
    knum=10
    qind_list = np.arange(knum)
    qxind, qyind, qzind = np.meshgrid(qind_list, qind_list, qind_list, indexing='ij')
    Gshift=G11tau[:, np.mod(qxind + kindx, knum), np.mod(qyind + kindy, knum), np.mod(qzind + kindz, knum)]
    Sigk_tau=np.sum(P22tau* Gshift,axis=(1,2,3))/knum**3*(-1)*U**2
    return Sigk_tau


#---------------------------------------------
def SC_Hartree(U,T,knum=10,nfreq=500):
    '''
    This function aims to get AFM coupling for Hubbard model based on a simple self-consistent Hartree. 
    The tadpole generated by the dressed GF is exactly the self-energy needed to construct such a dressed tadpole.
    '''
    beta=1/T
    mu=U/2
    split=0.1# break the G11 and G12 in the beginning. We cannot start with PM states.
    sig_empty=np.zeros((2*nfreq,knum,knum,knum),dtype=complex)
    sig_unity=np.ones((2*nfreq,knum,knum,knum),dtype=complex)
    z_1=z4D(beta,mu,sig_empty+split,knum,nfreq)#z-delta
    z_2=z4D(beta,mu,sig_empty-split,knum,nfreq)#z+delta
    G11_iom,G12_iom=G_iterative(knum,z_1,z_2,sig_empty)
    G22_iom=-G11_iom.conjugate()


    epsilon=0.00001
    diff=9999
    it=0
    n11prev=0
    n22prev=0    
    #--------------self-consistent Hartree-------------------
    # print('--------------self-consistent Hartree-------------------')
    while epsilon<diff:
        it+=1
        # n11=np.sum(G11_iom).real/beta/knum**3+1/2
        # n22=np.sum(G22_iom).real/beta/knum**3+1/2
        n11=particlenumber4D(G11_iom,beta)
        n22=particlenumber4D(G22_iom,beta)
        diff=np.abs(n11-n11prev)+np.abs(n22-n22prev)
        # print('iteration No.{} n11={} n22={} mag={} diff={}'.format(it,n11,n22,n11-n22,diff))
        z_1=z4D(beta,mu,U*n22*sig_unity,knum,nfreq)#z-delta
        z_2=z4D(beta,mu,U*n11*sig_unity,knum,nfreq)#z+delta
        G11_iom,G12_iom=G_iterative(knum,z_1,z_2,sig_empty)
        G22_iom=-G11_iom.conjugate()    
        n11prev=n11
        n22prev=n22    
        if it>1000:
            break
    # print('--------------SC Hartree Finished-------------------')
    # print('n11={} n22={} mag={} diff={}'.format(n11,n22,n11-n22,diff))
    # return U*(n22-1/2),U*(n11-1/2)# return 2 self-energies
    return U*n22,U*n11# return 2 self-energies

def check_mag_vs_alpha(U,T,knum=10,nfreq=500):
    beta=1/T
    mu=U/2
    mu=0
    
    SigHF1,SigHF2=SC_Hartree(U,T)
    alpha_list=np.arange(11)/10
    mag_list=np.zeros_like(alpha_list)
    sig_empty=np.zeros((2*nfreq,knum,knum,knum),dtype=complex)
    sig_unity=np.ones((2*nfreq,knum,knum,knum),dtype=complex)
    print('check_mag_vs_alpha: T={} U={}'.format(T,U))
    for ialp,alpha in enumerate(alpha_list):
        mu=U/2*alpha
        z_1=z4D(beta,mu,SigHF1*alpha*sig_unity,knum,nfreq)#z-delta
        z_2=z4D(beta,mu,SigHF2*alpha*sig_unity,knum,nfreq)#z+delta
        G11_iom,G12_iom=G_iterative(knum,z_1,z_2,sig_empty)
        G22_iom=-G11_iom.conjugate()    
        n11=np.sum(G11_iom).real/beta/knum**3+1/2
        n22=np.sum(G22_iom).real/beta/knum**3+1/2
        mag_list[ialp]=n11-n22
        print('alpha={} n11={} n22={} mag={} n={}'.format(alpha,n11,n22,n11-n22,n11+n22))
    plt.plot(alpha_list,mag_list)
    plt.title('mag vs alpha: T={} U={}'.format(T,U))
    plt.show()
    return 0


def perturbation(U,T,order,ifit=0,alpha=1.,knum=10,nfreq=500):
    '''
    This code aims to calculate the magnetization after perturbation.
    In default alpha=1, i.e. start from Hartree Fock.
    Currently alpha<1 is experimental. I am not so sure about how to do perturbation since we have the issue of chemical potential.
    '''
    debug=0
    ifconv=0
    beta=1/T
    mu=U/2
    if ifit==0:
        maxit=1
    else:
        maxit=100
    epsilon=0.0001# epsilon in SC_HARTREE
    sig_unity=np.ones((2*nfreq,knum,knum,knum),dtype=complex)
    sig_empty=np.zeros((2*nfreq,knum,knum,knum),dtype=complex)
    SigHF1,SigHF2=SC_Hartree(U,T)

    z_1=z4D(beta,mu*alpha,SigHF1*alpha*sig_unity,knum,nfreq)#z-delta
    z_2=z4D(beta,mu*alpha,SigHF2*alpha*sig_unity,knum,nfreq)#z+delta
    G11_iom,G12_iom=G_iterative(knum,z_1,z_2,sig_empty)
    G22_iom=-G11_iom.conjugate()  
    G11_tau=fft.fermion_fft_diagG(knum,G11_iom,beta,(SigHF1-U/2)*alpha*np.ones((2*nfreq),dtype=complex),mu*alpha)#*sig_unity
    G12_tau=fft.fast_ft_fermion(G12_iom,beta)
    G22_tau=G11_tau[::-1] 
    #-------------testing------------------------

    if order>=2:
        Sig2_11,Sig2_12=diagrams.sig2(G11_tau,G12_tau,G22_tau,knum,nfreq,U,beta)
        Sig2_22=-Sig2_11.conjugate()
    if order>=3:
        P22_tau=mpi_module.bubble_mpi(fft.precalcP_fft,knum,nfreq,11,G22_tau,G22_tau,0)
        P12_tau=mpi_module.bubble_mpi(fft.precalcP_fft,knum,nfreq,12,G12_tau,G12_tau,1)
        Sig3_11,Sig3_12=diagrams.sig3(G11_iom,G12_iom,G11_tau,G12_tau,G22_tau,knum,nfreq,U,beta)
        Sig3_22=-Sig3_11.conjugate()

    for it in np.arange(maxit):
        #-------------------------------------------
        sig_corr_11=np.zeros((2*nfreq,knum,knum,knum),dtype=complex)
        sig_corr_22=np.zeros((2*nfreq,knum,knum,knum),dtype=complex)
        sig_corr_12=np.zeros((2*nfreq,knum,knum,knum),dtype=complex)
        # n11=np.sum(G11_iom).real/beta/knum**3+1/2
        # n22=np.sum(G22_iom).real/beta/knum**3+1/2
        n11=particlenumber4D(G11_iom,beta)
        n22=particlenumber4D(G22_iom,beta)
        if order>=1: #if alpha=1, this order should be cancelled
            Sig1_11=U*n22-SigHF1*alpha-(1-alpha)*mu
            Sig1_22=U*n11-SigHF2*alpha-(1-alpha)*mu
            sig_corr_11+=Sig1_11
            sig_corr_22+=Sig1_22
            if ((U*n22-SigHF1)>epsilon or (U*n11-SigHF2)>epsilon) and ifit==0 and alpha==1:
                print('1st order: ', U*n22-SigHF1, U*n11-SigHF2, 'ERROR! this should be less than epsilon in SC_Hartree')
        if order>=2:
            sig_corr_11+=Sig2_11
            sig_corr_22+=Sig2_22
            sig_corr_12+=Sig2_12
            if ifit==0:# if alpha not equals to 1 we will need tadpole insertion on tadpole
                sigext2_11=diagrams.sig2_nonskeleton(G22_iom,G12_iom,Sig1_11,Sig1_22,knum,nfreq,U,beta)
                sigext2_22=-sigext2_11
                
                print('diagrams order1: {:4f}'.format(U*n22-SigHF1*alpha-(1-alpha)*mu))
                print('CT 2nd order:{:.4f}'.format(sigext2_11.real))
                sig_corr_11+=sigext2_11
                sig_corr_22+=sigext2_22
        if order>=3:
            if it==0:# this non-skeleton diagram should only be calculated once. they are 1st order insertion in second order skeleton
                sigext3def_11,sigext3def_12=diagrams.sig3_nonskeleton_DEF(G11_iom,G12_iom,G11_tau,G12_tau,P22_tau,P12_tau,Sig1_11,Sig1_22,beta,knum,nfreq,U)
                sigext3def_22=-sigext3def_11.conjugate()
            sig_corr_11+=(Sig3_11+sigext3def_11)#
            sig_corr_22+=(Sig3_22+sigext3def_22)#
            sig_corr_12+=(Sig3_12+sigext3def_12)    
            if ifit==0:
                sigext3a_11=diagrams.sig3_nonskeleton_A(G22_iom,G12_iom,Sig2_11,Sig2_22,Sig2_12,knum,nfreq,U,beta)#second order insertion on a hartree
                sigext3a_22=-sigext3a_11
                sigext3b_11=diagrams.sig3_nonskeleton_B(G22_iom,G12_iom,G11_iom,Sig1_11,Sig1_22,knum,nfreq,U,beta)
                sigext3b_22=-sigext3b_11
                sigext3c_11=diagrams.sig2_nonskeleton(G22_iom,G12_iom,sigext2_11,sigext2_22,knum,nfreq,U,beta)
                sigext3c_22=-sigext3c_11
                print('CT diagrams: a={:.4f} b={:.4f} c={:.4f} a+b+c={:.4f}'.format(sigext3a_11.real,sigext3b_11.real,sigext3c_11.real,sigext3a_11.real+sigext3b_11.real+sigext3c_11.real))
                sig_corr_11+=(sigext3a_11+sigext3b_11+sigext3c_11)
                sig_corr_22+=(sigext3a_22+sigext3b_22+sigext3c_22)
        zn_1=z4D(beta,mu*alpha,sig_corr_11+SigHF1*alpha,knum,nfreq)#z-delta
        zn_2=z4D(beta,mu*alpha,sig_corr_22+SigHF2*alpha,knum,nfreq)#z+delta
        G11_iom,Gn12_iom=G_iterative(knum,zn_1,zn_2,sig_corr_12)
        G22_iom=-G11_iom.conjugate()
        # nn11=np.sum(G11_iom).real/beta/knum**3+1/2
        # nn22=np.sum(G22_iom).real/beta/knum**3+1/2
        nn11=particlenumber4D(G11_iom,beta)
        nn22=particlenumber4D(G22_iom,beta)
        diff=np.abs(nn11-n11)

        
        if diff<epsilon:
            # print("converged!")
            ifconv=1
            break
    if ifconv==0 and ifit==1:
        print("not converged!")
    print('alpha={} order={},n11={:.4f} n22={:.4f} mag={:.4f} '.format(alpha,order,nn11,nn22,nn11-nn22))
    # zn_1=z4D(beta,mu,sig_corr_11+SigHF1,knum,nfreq)#z-delta
    # zn_2=z4D(beta,mu,sig_corr_22+SigHF2,knum,nfreq)#z+delta
    # Gn11_iom,Gn12_iom=G_iterative(knum,zn_1,zn_2,sig_corr_12)
    # Gn22_iom=-Gn11_iom.conjugate()
    # nn11=np.sum(Gn11_iom).real/beta/knum**3+1/2
    # nn22=np.sum(Gn22_iom).real/beta/knum**3+1/2
    # print('n11={} n22={} mag={} n={}'.format(nn11,nn22,nn11-nn22,nn11+nn22))
    return (nn11-nn22)

def plot_order(U, T, alpha=1.):
    order_arr = np.arange(4)
    mag_arr = np.zeros((2,4), dtype=float)
    for i in order_arr:
        mag_arr[0,i] = perturbation(U, T, i,0)
        mag_arr[1,i] = perturbation(U, T, i,1)

    plt.plot(order_arr, mag_arr[0], marker='o', linestyle='-',label='basic')
    plt.plot(order_arr, mag_arr[1], marker='^', linestyle='-',label='iterative')
    plt.title('Magnetization vs Order: U={} T={}'.format(U, T))
    plt.xticks(order_arr)
    plt.legend()
    plt.show()
    return 0

def plot_order_alpha():
    order_arr = np.arange(4)
    U=4
    T=0.15
    mag_arr = np.zeros((7,4), dtype=float)
    alp_arr_4=np.array([1,0.7,0.55,0.32,0.25,0.162,0.05])
    alp_arr_3=np.array([1,0.5,0.05])
    for i in order_arr:
        for ialp,alp in enumerate(alp_arr_4):
            mag_arr[ialp,i] = perturbation(U, T, i,0,alp)

    plt.plot(order_arr, mag_arr[0], marker='o', linestyle='-',label='alpha={}'.format(alp_arr_4[0]))
    plt.plot(order_arr, mag_arr[1], marker='^', linestyle='-',label='alpha={}'.format(alp_arr_4[1]))
    plt.plot(order_arr, mag_arr[2], marker='s', linestyle='-',label='alpha={}'.format(alp_arr_4[2]))
    plt.plot(order_arr, mag_arr[3], marker='p', linestyle='-',label='alpha={}'.format(alp_arr_4[3]))
    plt.plot(order_arr, mag_arr[4], marker='D', linestyle='-',label='alpha={}'.format(alp_arr_4[4]))
    plt.plot(order_arr, mag_arr[5], marker='h', linestyle='-',label='alpha={}'.format(alp_arr_4[5]))
    plt.plot(order_arr, mag_arr[6], marker='h', linestyle='-',label='alpha={}'.format(alp_arr_4[6]))
    for i in np.arange(7):
        for x, y in zip(order_arr, mag_arr[i]):
            plt.text(x, y, f'{y:.3f}', color='black', ha='center', va='bottom')
    plt.title('Magnetization vs Order: U={} T={}'.format(4, 0.15))
    plt.xticks(order_arr)
    plt.legend()
    plt.show()
    # U=3
    # T=0.3
    # for i in order_arr:
    #     for ialp,alp in enumerate(alp_arr_3):
    #         mag_arr[ialp,i] = perturbation(U, T, i,0,alp)

    # plt.plot(order_arr, mag_arr[0], marker='o', linestyle='-',label='alpha={}'.format(alp_arr_3[0]))
    # plt.plot(order_arr, mag_arr[1], marker='^', linestyle='-',label='alpha={}'.format(alp_arr_3[1]))
    # plt.plot(order_arr, mag_arr[2], marker='s', linestyle='-',label='alpha={}'.format(alp_arr_3[2]))
    # for i in np.arange(3):
    #     for x, y in zip(order_arr, mag_arr[i]):
    #         plt.text(x, y, f'{y:.3f}', color='black', ha='center', va='bottom')
    # plt.title('Magnetization vs Order: U={} T={}'.format(3, 0.3))
    # plt.xticks(order_arr)
    # plt.legend()
    # plt.show()
    return 0

def plot_order_alpha2(U,T,ifit=0):
    order_arr = np.arange(4)
    mag_arr = np.zeros((4,11), dtype=float)
    alp_arr=np.arange(11)/10
    for i in order_arr:
        for ialp,alp in enumerate(alp_arr):
            mag_arr[i,ialp] = perturbation(U, T, i,ifit,alp)

    plt.plot(alp_arr, mag_arr[0], marker='o', linestyle='-',label='HF 0th')
    plt.plot(alp_arr, mag_arr[1], marker='^', linestyle='-',label='HF 1st')
    plt.plot(alp_arr, mag_arr[2], marker='s', linestyle='-',label='HF 2nd')
    plt.plot(alp_arr, mag_arr[3], marker='p', linestyle='-',label='HF 3rd')

    plt.title('Magnetization vs Order: U={} T={}'.format(U,T))
    plt.legend()
    plt.show()
    plt.plot(alp_arr, mag_arr[1]-mag_arr[0], marker='^', linestyle='-',label='HF 1st-0th')
    plt.plot(alp_arr, mag_arr[2]-mag_arr[0], marker='s', linestyle='-',label='HF 2nd-0th')
    plt.plot(alp_arr, mag_arr[3]-mag_arr[0], marker='p', linestyle='-',label='HF 3rd-0th')
    plt.title('Magnetization vs Order: U={} T={}'.format(U, T))
    # plt.xticks(np.arange(4))
    plt.legend()
    plt.show()
    return 0

if __name__ == "__main__":
    # SC_Hartree(3,0.36)
    # check_mag_vs_alpha(4,0.15)
    # plot_order(3,0.3)
    # plot_order_alpha()
    # plot_order_alpha2(3,0.1,0)
    plot_order_alpha2(8,0.05)